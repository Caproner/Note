# 第七章 操作系统

本章主要讨论操作系统相关的基础知识

## 操作系统基础

操作系统的本质是介于计算机硬件和用户（其实更准确的说是用户及应用程序）之间的一层软件，这层软件用于调度管理计算机硬件和操作系统之上的其他软件，方便用户使用和管理计算机。

### 自举程序

在之前我们了解到，计算机要运行一个程序，需要将这个程序从存储空间载入内存中，然后再通过CPU进行【取指令->译码->执行】来执行程序。而操作系统负责的功能之一就是程序调度管理，即【将程序载入内存中】这个事情是由操作系统完成的。

但是操作系统本身也是程序，其执行本身也需要经过这样的操作。如果在同个套路下往深的思考就会变成鸡生蛋问题。

一种最直接的解决方案是，将整个操作系统写死在内存中，程序计数器默认指向该程序的第一行。显而易见的，这个操作十分傻逼。

另一种方式就是加一层套娃，将一个叫做**自举程序**的程序写入内存中。这个程序只负责将操作系统的启动部分写入内存，所以其占容量很小。于是计算机在通电之后就会先执行这个自举程序，再按顺序执行被装载进来的操作系统的启动部分。

### 操作系统演化

+ 批处理系统：在20世纪50年代，计算机刚发展的那会，计算机需要一个接一个的执行打孔卡上的程序。而负责批处理这些打孔卡的程序就是批处理操作系统（可能都还算不上程序，很可能就是通过接线等硬件手段完成的简单操作系统）。
+ 分时系统：分时系统允许将多个程序同时装进内存中，在每一个**时间片**决定各个硬件资源分别执行哪个程序。只要时间片足够小，在用户的眼中就像是多个程序同时运行。
+ 个人系统：也就是单用户操作系统。
+ 并行系统：现在的机子会出现多个CPU的情况，这个时候计算机就可以真正做到并行处理程序。适用于这种设计的操作系统称为并行系统。
+ 分布式系统：随着网络的发展，现在还会出现多台计算机通过网络相互连在一起构成一个主体。将这个主体看作是单个个体来设计的操作系统就是分布式操作系统。
+ 实时系统：实时系统用于在特定环境内所使用的，对时间精确度要求十分高的场景。这类系统一般被设计用于执行特定的任务（也就是没有外来的程序）。

## 操作系统组成

操作系统分为如下四个部分：

+ 内存管理器
+ 进程管理器
+ 设备管理器
+ 文件管理器

除了这四个部分，操作系统还会有一个用于跟用户交互的用户界面。

### 用户界面

用来跟用户交互的程序，例如说Unix系统的shell，或者Windows系统的窗口。

### 内存管理器

操作系统需要负责计算机的内存管理，使得程序能够正确高效的利用内存。

内存管理分为单道程序和多道程序。

#### 单道程序

在单道程序设计中，内存只会装载操作系统和当前运行的程序。其需要到程序运行结束之后才会被下一个程序取代。显然这会十分浪费硬件资源。

#### 多道程序

多道程序设计中，内存同一个时刻可以装入多个程序并轮流进行（按顺序运行或使用自身的优先级策略调度）。

多道程序模式细分下去还会有：

+ 分区调度：内存被分为许多个区，每个区装载一个程序，程序运行结束后再用下一个程序装载进去。
  + 每个区的大小是随着装载进来的程序决定的，这会带来的问题是，当计算机运行一段时间之后，由于新的程序不适应当前分好（也就是按之前运行的程序分好）的区，需要去找相对合适的（例如大一些的）区，这样会造成大量的内存资源浪费，而如果再重新分区的话又会造成时间上的浪费。
+ 分页调度：内存被切分为许多个**帧**，程序被切分为许多个**页**，一帧跟一页是一样大的（除了程序末页可能会小于帧大小）。计算机将需要运行的程序按页载入内存和运行。
  + 这样带来的好处是空间的充分利用，分页后的程序在内存中不需要是物理上连续的，这样就能保证内存的每个帧都能被利用。
  + 其缺点是，当一个程序开始运行的时候，仍旧需要将整个程序装载进内存（即使其分页了）。
+ 请求分页调度：相比较于分页调度而言，其不需要将程序的分页全都装载进内存，而是只需要装载其中需要的一页或几页即可。剩下的页仍旧存于硬盘中
  + 这样的机制诞生出了**虚拟内存技术**，即看起来占内存总量有30MB的程序通过请求分页调度和之后会讲到的请求分段调度来使得其部分载入内存，而使得可能只需要10MB的物理内存就能运行实际上占30MB的程序。
+ 请求分段调度：不考虑按页来分，而是根据程序模块分为大小不同的段，按段载入内存。
  + 其同样不需要全部载入
  + 即使程序分出来的每个段是不同大小的，但在内存中的段空间大小是一致的，故这种方式会出现比分页调度更多的空间浪费。
+ 请求分页和分段调度：在请求分段调度的基础上，对于过大的段采取分页策略，以减少空间的浪费。

### 进程管理器

进程管理简单的说就是程序运行的管理。

在现代的计算机中，关于指令集的术语被划分出三个：程序，作业，进程

> 此处不讨论线程跟协程

+ 程序：简单的讲就是指令集，其在非活动的状态下会存在磁盘中。
+ 作业：当一个程序被选中执行的时候，其就会成为作业。此时作业会在磁盘中处于**保持状态**。
  + 当一个进程终止的时候其也会先成为作业再成为程序，这个时候的作业处于**终止状态**
+ 进程：当一个作业被调入内存的时候，该作业成为进程。
  + 进程将会在CPU中在就绪，运行，等待这三个状态中切换。

#### 调度器

进程管理会涉及到两个调度器：作业调度器和进程调度器。

+ 作业调度器：用于负责从作业中创建一个进程和终止一个进程。
+ 进程调度器：负责管理进程状态和分配进程运行的调度器。

当然，也会存在其他用于专用用途的调度器，这里不再赘述。

#### 队列

简单的讲就是缓冲区。在现实的计算机中往往会有多个任务同时抢占资源，这个时候除了合理调度之外，就需要一个叫做队列的缓冲区来暂时存储这些任务（一般都是存任务的控制块，不可能存任务本身的）。

例如说：作业队列，I/O队列，进程就绪队列

进程管理器根据其策略从队列中选择下一个作业或进程执行，例如说FIFO，最段长度有限，最高优先级等等。

#### 进程同步问题

主要将两个：死锁和饿死

##### 死锁

简单的讲就是出现多个进程出现互相请求对方抢占的资源，导致涉及到的进程都无法进入运行态。

死锁发生需要满足四个必要条件：

+ 互斥：一个资源只能被一个进程占有
+ 资源占有：进程会占用住资源直到其结束使用
+ 抢先：进程通过抢占来获得资源，而不是操作系统计划地分配它们，操作系统也不能重新临时再分配资源
+ 循环等待：所有的进程和资源都包含在一个循环中

换句话说，只要打破其中一个条件，就可以解除死锁

一般而言操作系统都会采取鸵鸟策略（GTMD死锁老子不管你们爱咋咋地）或者设置资源占有的超时时间来防止或解除死锁。

> 对于前一个策略而言的解除死锁的策略就相当于，只要我不知道它就不存在。
>
> 不过这的确是种高效的策略，其一在于死锁发生的概率很低，其二在于目前知道的任何死锁解除和预防策略要么很花功夫（例如银行家算法），要么需要作出一些牺牲（例如设置资源占有超时时间，这就意味着不难设计出要长期占有资源的程序），其三在于一旦发生了用户要么无感知，要么感知了之后就会去自己杀死一个进程来解决。

##### 饿死

当一个进程需要使用的资源一直都被其他进程占用（或轮流使用）使得其一直得不到该资源而处于等待状态的情况下，这个进程我们就称为其被饿死了。

解决这种状况的策略是从调度算法入手，尽可能不要用太傻逼的调度方法（例如优先级分配策略不好的固定优先级的调度算法，当持续有高优先级的进程入驻CPU的时候，低优先级的进程就很可能会饿死）。

### 设备管理器

设备管理器主要管理输入/输出设备，其主要职责有：

+ 监视所有I/O设备，以保证其能正常运行
+ 维护I/O队列，以及其调度策略

### 文件管理器

文件管理器主要的职责有：

+ 控制文件访问以及其访问权限
+ 管理文件的创建删除和修改
+ 管理文件名系统
+ 管理文件的存储形式
+ 负责文件的归档和备份